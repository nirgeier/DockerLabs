{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DockerLabs Hands-on","text":"<ul> <li>Welcome to the lab workspace that accompanies the DockerLabs project. </li> <li>Each folder below is a self-contained lab that you can complete independently to sharpen specific containerization skills. </li> <li>Follow the README file in each lab for detailed steps.</li> </ul>"},{"location":"#how-to-use-those-labs","title":"How to Use Those Labs","text":"<ul> <li>There are several ways to run the Docker Labs. </li> <li>Choose the method that works best for you.<ul> <li> Killercoda  (Recommended)</li> <li>\ud83d\udcdc From Source</li> <li> Using Google Cloud Shell</li> </ul> </li> </ul>  Killercoda  (Recommended)\ud83d\udcdc From Source Using Google Cloud Shell <ul> <li>The easiest way to get started with the labs</li> <li>Learn Docker in your browser without any local installation</li> </ul> <p>\ud83c\udf10 Launch on Killercoda</p> <p>Benefits:</p> <ul> <li>No installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> </ul> <p>For those who prefer to run it directly on their machine:</p> <p><pre><code># Clone the repository\ngit clone https://github.com/nirgeier/DockerLabs.git\n# Change to the Labs directory\ncd DockerLabs/Labs\n# Start with the Docker CLI lab\ncd 001-DockerCli\n# Follow the instructions in the README of each lab\ncat README.md\n</code></pre> Prerequisites:</p> <ul> <li>Ansible installed on your system</li> <li>A Unix-like operating system (Linux, macOS, or Windows with WSL)</li> <li>Basic command-line tools</li> </ul> <ul> <li>Google Cloud Shell provides a free, browser-based environment with all necessary tools pre-installed.</li> <li>Click on the <code>Open in Google Cloud Shell</code> button below:</li> </ul> <p></p> <ul> <li>The repository will automatically be cloned into a free Cloud instance.</li> <li>Use CTRL + click to open it in a new window.</li> <li>Follow the instructions in the README of each lab.</li> </ul> <p>Benefits:</p> <ul> <li>No local installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> <li>Free tier available</li> </ul>"},{"location":"#lab-index","title":"Lab Index","text":"Lab Description 001 - Docker CLI Practice the core Docker CLI commands for running, inspecting, and managing containers. 002 - Dockerfile Basics Build your first Node.js container image from a Dockerfile and publish it to a registry. 003 - Dockerfile Multi-Stage Learn how multi-stage Dockerfiles produce lean images across build targets. 004 - Local Registry Stand up a private registry, retag images, and push or pull them locally. 005 - Docker Compose Stack Orchestrate a WordPress and MariaDB stack with Docker Compose. 006 - Compose Environments Structure Compose files and env vars for dev and prod workflows. 007 - Image Layers &amp; Dive Explore image layer creation and visualize them with the dive tool. 008 - CRI <code>crictl</code> Placeholder lab for container runtime interface tooling using crictl. 009 - Multistage Patterns Review advanced multistage techniques with language-specific examples. 010 - Compose Reference Quick reference of everyday docker-compose commands and usage. 011 - Docker Bake Use Docker Buildx Bake to coordinate complex, multi-target image builds. 012 - gVisor Seccomp Apply a gVisor runtime profile to block privileged syscalls inside a container. 100 - Hands-On Intro Guided Node.js exercise covering the full build, run, and publish workflow. <p>Happy learning and hacking with Docker!</p>"},{"location":"001-DockerCli/","title":"001-DockerCli","text":""},{"location":"001-DockerCli/#lab-001-docker-cli","title":"Lab 001 - Docker CLI","text":"<ul> <li>This lab covers the basics of the Docker CLI.</li> <li>You will learn how to run, manage, and interact with Docker containers using various Docker commands.</li> <li>By the end of this lab, you will have a solid understanding of how to use the Docker CLI for container management.</li> </ul>"},{"location":"001-DockerCli/#docker-cli-commands","title":"Docker CLI Commands","text":"<ul> <li><code>docker attach</code></li> <li><code>docker build</code></li> <li><code>docker commit</code></li> <li><code>docker cp</code></li> <li><code>docker create</code></li> <li><code>docker exec</code></li> <li><code>docker images</code></li> <li><code>docker inspect</code></li> <li><code>docker kill</code></li> <li><code>docker logs</code></li> <li><code>docker pause</code></li> <li><code>docker ps</code></li> <li><code>docker pull</code></li> <li><code>docker push</code></li> <li><code>docker rename</code></li> <li><code>docker restart</code></li> <li><code>docker rm</code></li> <li><code>docker rmi</code></li> <li><code>docker run</code></li> <li><code>docker run -a</code></li> <li><code>docker run -d</code></li> <li><code>docker run -it</code></li> <li><code>docker run -name</code></li> <li><code>docker run -p</code></li> <li><code>docker run &lt;command&gt;</code></li> <li><code>docker start</code></li> <li><code>docker stats</code></li> <li><code>docker stop</code></li> <li><code>docker top</code></li> <li><code>docker unpause</code></li> <li><code>docker wait</code></li> </ul>"},{"location":"001-DockerCli/#docker-attach","title":"<code>docker attach</code>","text":"<ul> <li><code>docker attach</code> is used to attach your terminal to a running container.</li> <li>This is useful when you want to interact with a container that is already running.</li> <li>For example, if you have a container running a shell or an application that accepts input, you can use <code>docker attach</code> to connect to it.</li> </ul> <pre><code># Spin an alpine image and start it in the background\ndocker run -it -d --name alpine001 alpine sleep 10000\n\n# Attach to the container and start a shell inside it\ndocker attach alpine001\n</code></pre> <p>Detaching from a Container</p> <ul> <li>To detach from the container without stopping it, you can use the CTRL + P followed by CTRL + Q key combination.    </li> <li>This will leave the container running in the background while you return to your terminal.  <ul> <li>This detach sequence only works if the container was started with the <code>-it</code> flags (interactive with a TTY)</li> </ul> </li> </ul>"},{"location":"001-DockerCli/#docker-build","title":"<code>docker build</code>","text":"<ul> <li><code>docker build</code> creates a Docker image from a Dockerfile.</li> <li> <p>This is one of the most important commands for creating custom images.</p> <pre><code># Create a simple Dockerfile\nmkdir -p /tmp/docker-build-example\ncd /tmp/docker-build-example\n\ncat &lt;&lt;'EOF' &gt; Dockerfile\nFROM alpine:latest\nRUN apk add --no-cache curl\nCMD [\"echo\", \"Hello from custom image\"]\nEOF\n\n# Build the image with a tag\ndocker build -t my-custom-alpine:v1.0 .\n\n# Build with a different tag\ndocker build -t my-custom-alpine:latest .\n\n# Build without using cache\ndocker build --no-cache -t my-custom-alpine:v1.0 .\n\n# Test the built image\ndocker run --rm my-custom-alpine:v1.0\n\n# Clean up\ncd -\nrm -rf /tmp/docker-build-example\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-commit","title":"<code>docker commit</code>","text":"<ul> <li> <p><code>docker commit</code> will create a new images out of an existing container.</p> <pre><code># Clean up and remove the container\ndocker stop nginx\ndocker rm   nginx\n\n# Spin the container\ndocker  run  -it -d -p 8888:80 --name nginx nginx\n\n# Wait for the container to start\nsleep 5\n\n# Prepare the desired welcome page\ndocker  exec -it nginx sh -c \"                  \\\n        echo 'This is a custom message ... ' &gt;  \\\n        /usr/share/nginx/html/index.html\"\n\n# Verify the changes\ncurl -s localhost:8888\n\n# Create the custom image\ndocker commit nginx nirgeier/custom-nginx-image\n\n# Clean up and remove the container\ndocker stop nginx\ndocker rm   nginx\n\n# Push to the registry\ndocker push nirgeier/custom-nginx-image\n\n# Clean up and remove the container\ndocker stop custom-nginx\ndocker rm   custom-nginx\n\n# Push to the registry\ndocker  run -it -d --name custom-nginx  \\\n        -p 8888:80                      \\\n        nirgeier/custom-nginx-image\n\n# Wait for the container to start\nsleep 5\n\n# Verify the changes\ncurl -s localhost:8888\n\n# Clean up and remove the container\ndocker stop custom-nginx\ndocker rm   custom-nginx\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-cp","title":"<code>docker cp</code>","text":"<ul> <li><code>docker cp</code> is used to copy files between the container and the host</li> <li>Lets spin a container and then lets grab the logs of this container to our host</li> </ul> <p>Copying files from and to a Container</p> <p>Since container are \u201cfile system\u201d we can grab files even when the container is stopped.</p> <ul> <li> <p>Example 1 - Copy file from Container to Host</p> <pre><code># Spin a container\ndocker run -it -d --name nginx -p 8888:80 nginx\n\n# grab the nginx default configuration \ndocker cp nginx:/etc/nginx/nginx.conf nginx.conf \n\n# Verify that the file exists locally\ncat nginx.conf \n</code></pre> </li> <li> <p>Example 2 - Copy file from Host to Container</p> <ul> <li>In the second example we will upload file to our container</li> <li>We will change the default nginx welcome page with our own page</li> </ul> <pre><code># Prepare the desired welcome page\necho 'Welcome to the world of Docker' &gt; index.html\n\n# Copy the file to the container \ndocker cp index.html nginx:/usr/share/nginx/html\n\n# Test the changes to the container\ncurl -s localhost:8888\n\n# Clean up and remove the container\ndocker stop nginx\ndocker rm   nginx\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-create","title":"<code>docker create</code>","text":"<ul> <li><code>docker create</code> creates a new container but does not start it.</li> <li>This is useful when you want to prepare a container and start it later.     <pre><code># Create a container without starting it\ndocker create --name my-nginx nginx\n\n# Verify the container is created but not running\ndocker ps -a | grep my-nginx\n\n# Create a container with port mapping\ndocker create --name web-server -p 8080:80 nginx\n\n# Create with environment variables\ndocker create --name db-container -e POSTGRES_PASSWORD=secret postgres\n\n# Create with volume mount\ndocker create --name data-container -v /data alpine\n\n# Start the created container\ndocker start my-nginx\n\n# Clean up\ndocker stop my-nginx\ndocker rm my-nginx web-server db-container data-container\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-exec","title":"<code>docker exec</code>","text":"<ul> <li>Execute a command in a running container     <pre><code># Remove old containers with the same name\ndocker stop alpine001\ndocker rm   alpine001\n\n# Spin an alpine image\ndocker run -it -d --name alpine001 alpine sleep 10000\n\n# Test that curl is not installed on the container\ndocker exec -it alpine001 curl\n\n# Install a new package on the container\ndocker exec -it alpine001 apk add curl\n\n# Test that curl is installed\ndocker exec -it alpine001 curl codewizard.co.il\n\n# Interact with the alpine image and open bash shell\ndocker exec -it alpine001 sh\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-images","title":"<code>docker images</code>","text":"<ul> <li><code>docker images</code> lists all Docker images on your system.</li> <li> <p>This command helps you see what images you have available locally.</p> <pre><code># List all images\ndocker images\n\n# List images with specific format\ndocker images --format \"table {{.Repository}}\\t{{.Tag}}\\t{{.Size}}\"\n\n# List all image IDs\ndocker images -q\n\n# List dangling images (images with no tag)\ndocker images -f \"dangling=true\"\n\n# Filter images by name\ndocker images alpine\n\n# Show all images including intermediate layers\ndocker images -a\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-inspect","title":"<code>docker inspect</code>","text":"<ul> <li><code>docker inspect</code> provides detailed information about Docker objects (containers, images, volumes, networks).</li> <li>Returns a JSON array with all the metadata.     <pre><code># Create a container for inspection\ndocker run -d --name nginx-inspect -p 8080:80 nginx\n\n# Inspect a container\ndocker inspect nginx-inspect\n\n# Get specific information using format flag\ndocker inspect --format='{{.State.Running}}' nginx-inspect\n\n# Get IP address of container\ndocker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' nginx-inspect\n\n# Inspect an image\ndocker inspect nginx:latest\n\n# Get image creation date\ndocker inspect --format='{{.Created}}' nginx:latest\n\n# Clean up\ndocker stop nginx-inspect\ndocker rm nginx-inspect\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-kill","title":"<code>docker kill</code>","text":"<ul> <li><code>docker kill</code> immediately terminates a running container.</li> <li>Unlike <code>docker stop</code>, it sends SIGKILL by default (no graceful shutdown).     <pre><code># Create a running container\ndocker run -d --name kill-test alpine sleep 10000\n\n# Kill the container immediately\ndocker kill kill-test\n\n# Verify the container is stopped\ndocker ps -a | grep kill-test\n\n# Kill with specific signal\ndocker run -d --name kill-test2 nginx\ndocker kill --signal=SIGTERM kill-test2\n\n# Kill multiple containers\ndocker run -d --name c1 alpine sleep 1000\ndocker run -d --name c2 alpine sleep 1000\ndocker kill c1 c2\n\n# Clean up\ndocker rm kill-test kill-test2 c1 c2\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-logs","title":"<code>docker logs</code>","text":"<ul> <li><code>docker logs</code> fetches the logs of a container.</li> <li>Useful for debugging and monitoring container output.</li> <li>By default, it shows all logs since the container started.</li> <li>You can use various options to filter and format the logs.     <pre><code># Create a container that generates logs\ndocker run -d --name log-example alpine sh -c \"while true; do echo 'Hello from container'; sleep 2; done\"\n\n# View container logs\ndocker logs log-example\n\n# Follow log output (like tail -f)\ndocker logs -f log-example\n\n# Show only last 10 lines\ndocker logs --tail 10 log-example\n\n# Show logs with timestamps\ndocker logs -t log-example\n\n# Show logs since specific time\ndocker logs --since 5m log-example\n\n# Combine options\ndocker logs -f --tail 5 -t log-example\n\n# Clean up (press Ctrl+C to stop following logs)\ndocker stop log-example\ndocker rm log-example\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-pause","title":"<code>docker pause</code>","text":"<ul> <li><code>docker pause</code> suspends all processes in a container.</li> <li> <p>The container continues to exist but is frozen.</p> <pre><code># Create a running container\ndocker run -d --name pause-test alpine sh -c \"while true; do echo 'Running'; sleep 1; done\"\n\n# Pause the container\ndocker pause pause-test\n\n# Verify the container is paused\ndocker ps -a | grep pause-test\n\n# Try to see logs (no new logs while paused)\ndocker logs --tail 5 pause-test\n\n# Note: Container remains paused until unpaused\n# See docker unpause to resume\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-ps","title":"<code>docker ps</code>","text":"<ul> <li>The \u201cproblem\u201d with the previous command is that the container is not removed once it exits.</li> <li>Lets look at the list of containers that we have right now on the host machine     <pre><code># List exiting containers on our host machine\n\n# Display running containers\ndocker ps\n\n# Display all containers\ndocker ps -a\n\n# Display all containers ids\ndocker ps -aq\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-pull","title":"<code>docker pull</code>","text":"<ul> <li><code>docker pull</code> downloads an image from a Docker registry (like Docker Hub).</li> <li>This command is useful when you want to download an image without running it immediately.     <pre><code># Pull the latest version of an image\ndocker pull alpine:latest\n\n# Pull a specific version\ndocker pull nginx:1.21\n\n# Pull from a specific registry\ndocker pull gcr.io/google-containers/busybox\n\n# Pull all tags of a repository\ndocker pull --all-tags alpine\n\n# Verify the pulled image\ndocker images | grep alpine\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-push","title":"<code>docker push</code>","text":"<ul> <li><code>docker push</code> uploads an image to a Docker registry.</li> <li>You need to be logged in to the registry and have proper permissions.     <pre><code># Tag an image for pushing (replace 'yourusername' with your Docker Hub username)\ndocker tag alpine:latest yourusername/my-alpine:v1.0\n\n# Login to Docker Hub (you'll be prompted for credentials)\n# docker login\n\n# Push the image to Docker Hub\n# docker push yourusername/my-alpine:v1.0\n\n# Push all tags\n# docker push --all-tags yourusername/my-alpine\n\n# Note: The push commands are commented out to prevent accidental pushes\n# Uncomment and replace 'yourusername' with your actual username when ready to use\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-rename","title":"<code>docker rename</code>","text":"<ul> <li><code>docker rename</code> changes the name of an existing container.</li> <li> <p>Useful for organizing or clarifying container purposes.</p> <pre><code># Create a container with a generic name\ndocker run -d --name old-name alpine sleep 10000\n\n# Rename the container\ndocker rename old-name new-name\n\n# Verify the new name\ndocker ps | grep new-name\n\n# Clean up\ndocker stop new-name\ndocker rm new-name\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-restart","title":"<code>docker restart</code>","text":"<ul> <li><code>docker restart</code> stops and then starts a container.</li> <li> <p>Combines <code>docker stop</code> and <code>docker start</code> in one command.</p> <pre><code># Create a running container\ndocker run -d --name restart-test nginx\n\n# Restart the container (default 10 second grace period)\ndocker restart restart-test\n\n# Restart with custom timeout\ndocker restart -t 30 restart-test\n\n# Restart multiple containers\ndocker run -d --name r1 alpine sleep 1000\ndocker run -d --name r2 alpine sleep 1000\ndocker restart r1 r2\n\n# Clean up\ndocker stop restart-test r1 r2\ndocker rm restart-test r1 r2\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-rm","title":"<code>docker rm</code>","text":"<ul> <li>Lets clean and remove the containers which are not running anymore</li> <li><code>docker rm</code> removes one or more stopped containers from your system.</li> <li>This helps free up system resources by deleting containers that are no longer needed.</li> </ul> <p>Removing Containers</p> <ul> <li>You <code>cannot</code> remove a running container without stopping it first.</li> <li>Use <code>docker ps -a</code> to list all containers (including stopped ones) before removing them.</li> <li>Warning: This action is irreversible.</li> </ul> <ul> <li>Example:     <pre><code># Remove all stopped containers\n# We use docker rm with the previous command we learned docker ps\ndocker rm $(docker ps -aq)\n\n# Verify that only running containers are still running\ndocker ps -a\n\n# Remove a specific container (must be stopped first)\ndocker stop nginx\ndocker rm nginx\n\n# Force remove a running container\ndocker rm -f nginx\n\n# Remove multiple containers\ndocker rm container1 container2 container3\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-rmi","title":"<code>docker rmi</code>","text":"<ul> <li><code>docker rmi</code> removes one or more Docker images from your system.</li> <li>This helps free up disk space by removing unused images.</li> <li>You cannot remove an image that is being used by a running container.</li> <li>If you need to remove such an image, you must stop and remove the container using it first.</li> <li>Tip: Use <code>docker ps -a</code> to list all containers (including stopped ones) before removing them.     <pre><code># Remove a specific image\ndocker rmi alpine:latest\n\n# Remove multiple images\ndocker rmi image1:tag1 image2:tag2\n\n# Remove image by ID\ndocker rmi abc123def456\n\n# Force remove an image (even if containers are using it)\ndocker rmi -f nginx:latest\n\n# Remove all dangling images (untagged images)\ndocker rmi $(docker images -f \"dangling=true\" -q)\n\n# Remove all images\n# WARNING: This removes ALL images on your system\n# docker rmi $(docker images -q)\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-run","title":"<code>docker run</code>","text":"<ul> <li>The <code>run</code> command container many options (flags), we will not cover all of them</li> <li>docs.docker.com - run</li> <li>Run your first container:      <pre><code># Run the first container\ndocker run hello-world\n\n### Output:\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n...\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-run-a","title":"<code>docker run -a</code>","text":"<ul> <li>The <code>--attach</code> [<code>-a</code>] flag tells docker run to bind to the container\u2019s <code>STDIN</code>, <code>STDOUT</code> or <code>STDERR</code>.      <pre><code># Pass input from stdin to container\ndocker run -a stdout alpine echo \"Docker rocks !!\"\n\n# Redirect stdout logs to a file\ndocker run -a stdout -a stderr alpine echo 'Docker rocks again !!' &gt; log.txt 2&gt;&amp;1\n\n# Print the log content\ncat log.txt\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-run-d","title":"<code>docker run -d</code>","text":"<ul> <li>Spin up the container which will run in the background</li> <li>By default when you spin a docker container it will attach itself to the current terminal.</li> <li>In order to avoid it we will use the -d flag to specify that the container should be running in the background.     <pre><code># Spin an nginx in the background.\n# Add a sleep timeout so that the container will not exit immediately\ndocker run -d alpine sleep 10000\n\n# Verify that the container is still running\ndocker ps -a\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-run-it","title":"<code>docker run -it</code>","text":"<p>Interactive Terminal</p> <ul> <li>The flags <code>-it</code> stands for:  <code>-i</code> [<code>--interactive</code>]   keeps the container\u2019s STDIN open, and lets you send input to the container through standard input.   <code>-t</code> [<code>--tty</code>]   Attaches a pseudo-TTY to the container, connecting your terminal to the I/O streams of the container.</li> </ul> <ul> <li>Example - Run an interactive shell inside an alpine container     <pre><code># Execute a command on the container and interact with the container\n# This command will change the password for root user\ndocker run -it alpine passwd root\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-run-name","title":"<code>docker run -name</code>","text":"<ul> <li>By default the container will be assigned a semi-random name based upon the following code: docker-ce/names-generator.go</li> <li>We can assign our desired name to the container with the <code>--name</code> option     <pre><code># Spin an nginx in the background.\n# Add a sleep timeout so that the container will not exit immediately\ndocker run --name alpine001 alpine\n\n# Verify that the container has been created with the given name\ndocker ps -a |  grep alpine001\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-run-p","title":"<code>docker run -p</code>","text":"<p>Port Mapping</p> <ul> <li>We can specify the exact ports we wish to open <code>-p</code> or open them all <code>-P</code> </li> </ul> <ul> <li>Run a container and connect to a port on the host which will be used to connect to the container     <pre><code># Execute an nginx container and test the container\n\n# Remove any containers with the same name\ndocker stop nginx\ndocker rm   nginx\n\n# We will combine few flags here\ndocker  run   -it  --rm     \\\n              -d            \\\n              -p 8888:80    \\\n              --name nginx  \\\n              nginx\n\n# Wait for the container to be created\nsleep 3\n\n# test the container\ncurl -s localhost:8888\n\n# Remove the container\ndocker kill nginx\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-start","title":"<code>docker start</code>","text":"<ul> <li><code>docker start</code> starts one or more stopped containers.</li> <li>Unlike <code>docker run</code>, this command starts an existing container.</li> <li>It does not create a new container.     <pre><code># Create a container but don't start it immediately\ndocker create --name my-alpine alpine echo \"Hello World\"\n\n# Start the container\ndocker start my-alpine\n\n# Start and attach to container output\ndocker start -a my-alpine\n\n# Start multiple containers\ndocker start container1 container2 container3\n\n# Start a stopped container interactively\ndocker run -it --name interactive-alpine alpine sh\n# (exit the shell to stop the container)\ndocker start -ai interactive-alpine\n\n# Clean up\ndocker rm my-alpine interactive-alpine\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-stats","title":"<code>docker stats</code>","text":"<ul> <li><code>docker stats</code> displays a live stream of resource usage statistics for containers.</li> <li>Shows CPU, memory, network I/O, and disk I/O usage.</li> <li>Useful for monitoring container performance in real-time.</li> <li>Can be used to identify resource bottlenecks and optimize container performance.</li> <li>Supports filtering and formatting options for customized output.     <pre><code># Create some containers\ndocker run -d --name stats-test1 nginx\ndocker run -d --name stats-test2 alpine sleep 10000\n\n# Display stats for all running containers (live stream)\n# Press Ctrl+C to exit\ndocker stats\n\n# Display stats for specific containers\ndocker stats stats-test1 stats-test2\n\n# Display stats without streaming (single snapshot)\ndocker stats --no-stream\n\n# Custom format\ndocker stats --format \"table {{.Container}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\"\n\n# Clean up\ndocker stop stats-test1 stats-test2\ndocker rm stats-test1 stats-test2\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-stop","title":"<code>docker stop</code>","text":"<ul> <li><code>docker stop</code> stops one or more running containers gracefully.</li> <li> <p>Sends SIGTERM signal first, then SIGKILL after grace period.</p> <pre><code># Create a running container\ndocker run -d --name test-nginx nginx\n\n# Stop the container (default 10 second grace period)\ndocker stop test-nginx\n\n# Stop with custom timeout\ndocker stop -t 30 test-nginx\n\n# Stop multiple containers\ndocker stop container1 container2 container3\n\n# Stop all running containers\ndocker stop $(docker ps -q)\n\n# Verify container is stopped\ndocker ps -a | grep test-nginx\n\n# Clean up\ndocker rm test-nginx\n</code></pre> </li> </ul>"},{"location":"001-DockerCli/#docker-top","title":"<code>docker top</code>","text":"<ul> <li><code>docker top</code> displays the running processes inside a container.</li> <li>Similar to the Linux <code>top</code> command but for containers.   <pre><code># Create a running container\ndocker run -d --name top-test nginx\n\n# Display running processes in the container\ndocker top top-test\n\n# Display with custom ps options\ndocker top top-test aux\n\n# Display specific columns\ndocker top top-test -eo pid,comm\n\n# Create a busier container to see more processes\ndocker run -d --name busy-container alpine sh -c \"sleep 100 &amp; sleep 200 &amp; sleep 300 &amp; wait\"\ndocker top busy-container\n\n# Clean up\ndocker stop top-test busy-container\ndocker rm top-test busy-container\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-unpause","title":"<code>docker unpause</code>","text":"<ul> <li><code>docker unpause</code> resumes all processes in a paused container.</li> <li>Used in conjunction with <code>docker pause</code>.   <pre><code># Create and pause a container\ndocker run -d --name unpause-test alpine sh -c \"while true; do echo 'Running'; sleep 1; done\"\ndocker pause unpause-test\n\n# Verify container is paused\ndocker ps -a | grep unpause-test\n\n# Unpause the container\ndocker unpause unpause-test\n\n# Verify container is running again\ndocker ps | grep unpause-test\n\n# Check logs to see it resumed\ndocker logs --tail 5 unpause-test\n\n# Clean up\ndocker stop unpause-test\ndocker rm unpause-test\n</code></pre></li> </ul>"},{"location":"001-DockerCli/#docker-wait","title":"<code>docker wait</code>","text":"<ul> <li><code>docker wait</code> blocks until one or more containers stop.</li> <li> <p>Returns the exit code of the container.</p> <pre><code># Create a container that will exit after 5 seconds\ndocker run -d --name wait-test alpine sh -c \"sleep 5; exit 42\"\n\n# Wait for the container to exit and get the exit code\necho \"Waiting for container to exit...\"\ndocker wait wait-test\n# This will return 42 after 5 seconds\n\n# Wait for multiple containers\ndocker run -d --name w1 alpine sh -c \"sleep 3; exit 0\"\ndocker run -d --name w2 alpine sh -c \"sleep 2; exit 1\"\ndocker wait w1 w2\n\n# Clean up\ndocker rm wait-test w1 w2\n</code></pre> </li> </ul>"},{"location":"002-DockerFile/","title":"002-DockerFile","text":""},{"location":"002-DockerFile/#lab-002-create-a-basic-container-using-dockerfile","title":"Lab 002 - Create a basic container using Dockerfile","text":"<ul> <li>In this lab we will create our first container using <code>Dockerfile</code></li> <li>The container will be used to serve a simple <code>NodeJs</code> web server</li> <li>No NodeJs knowledge is required</li> <li>You will need to create, build, tag &amp; push your container to DockerHub</li> <li> <p>The lab is divided into the several tasks.</p> <ul> <li>01. Prepare the server code</li> <li>02. Test the <code>server.js</code> code</li> <li>03. Write the <code>Dockerfile</code></li> <li>04. Build the image</li> <li>05. Login to DockerHub</li> <li>06. Push the image to DockerHub</li> <li>07. Verify the push</li> <li>08. Test the image</li> <li>09. Test the server</li> <li>10. Clean up</li> </ul> </li> </ul>"},{"location":"002-DockerFile/#01-prepare-the-server-code","title":"01. Prepare the server code","text":"<ul> <li>Our container will include the following NodeJs simple web server</li> <li>Copy the code below and save it to a file named <code>server.js</code> <pre><code>//\n// Filename: server.js\n//\n// Simple NodeJs Server\n// The server is listening by default to port 8888\n//\n\n// import the HTTP module\nvar http = require('http');\n\n// Define a port we want to listen to\n// Later on we will pass the port as env parameter\n// Default port is set to 8888\nconst PORT= process.env.PORT || 8888; \n\n// Create the server and listen for requests\n// Create the server and listen for requests\nhttp.createServer((request, response)=&gt;{\n    response.end('Server is running.!! You asked for: ' + request.url);\n}).listen(PORT, ()=&gt;{\n    // Callback is triggered when server is getting a request\n    console.log(\"Server listening on: http://localhost:%s\", PORT);\n});\n</code></pre></li> </ul>"},{"location":"002-DockerFile/#02-test-the-serverjs-code","title":"02. Test the <code>server.js</code> code","text":"<ul> <li>Before we \u201cpack\u201d our code in Docker image lets test the code</li> <li>We will test the code inside <code>nodejs</code> docker      <pre><code># Test the node code\n#   --rm            =   remove the container when done\n#   -d              =   run in detached mode\n#   -p              =   open the required ports\n#   -v              =   volume\n#   -w              =   workdir\n#   --name          =   the container name\n#   node            =   Execute a nodejs container to test our code\n#   node server.js  =   Execute the code\ndocker   run --rm -d       \\\n  -v     $(pwd):/usr/src  \\\n  -w     /usr/src         \\\n  -p     8888:8888        \\\n  --name node_server      \\\n  node                    \\\n  node server.js   \n</code></pre></li> </ul>"},{"location":"002-DockerFile/#03-write-the-dockerfile","title":"03. Write the <code>Dockerfile</code>","text":"<ul> <li>Now lets create a <code>Dockerfile</code> with the code we just created above</li> <li>The <code>Dockerfile</code> will be based upon <code>nodejs</code> image and will include our <code>server.js</code> <pre><code>#\n# Filename: Dockerfile\n#\n# Use node as our base image\nFROM      node\n\n# Optional: Set working directory\nWORKDIR   /usr/src\n\n# Copy the server code to our working directory [.]\nCOPY      server.js .\n\n# Mark the port which will required for the server\nEXPOSE    8888\n\n# Start the server when the container is started\nCMD       [\"node\", \"./server.js\"]\n</code></pre></li> </ul>"},{"location":"002-DockerFile/#04-build-the-image","title":"04 - Build the image","text":"<ul> <li>Once we have the docker file we can build the image</li> <li>Once the image is ready we will push it to DockerHub so you will need an account.</li> <li>We will name the image: \u201cYour Dockerhub username/repository:version\u201d     <pre><code>###\n### Build the image\n### Tag the image with the following \n###     DockerHub username/repository:version\n###\ndocker build -t nirgeier/docker-labs-002 .\n</code></pre></li> </ul>"},{"location":"002-DockerFile/#05-login-to-dockerhub","title":"05. Login to DockerHub","text":"<ul> <li>Login to DockerHub</li> <li>Execute <code>docker login</code> and enter your Docker Hub credentials when prompted</li> <li>If you don\u2019t have a DockerHub account, create one at https://hub.docker.com/signup</li> <li>You will need to push the image to DockerHub in the next step</li> </ul>"},{"location":"002-DockerFile/#06-push-the-image-to-dockerhub","title":"06. - Push the image to DockerHub","text":"<p>Docker Login Required</p> <p>You must login to Docker Hub before you can push to DockerHub</p> <ul> <li>Example: <code>docker push username/image:tag</code> </li> </ul>"},{"location":"002-DockerFile/#07-verify-the-push","title":"07. Verify the push","text":"<ul> <li>Login to your DockerHub account and verify that the image exists under your DockerHub account.</li> </ul>"},{"location":"002-DockerFile/#08-test-the-image","title":"08 - Test the image","text":"<ul> <li>Last step is to test our image</li> <li>To do so we will pull and run the image from DockerHub</li> <li>Once the container is started we will test the server     <pre><code>###\n### Pull the image from DockerHub\n###  Replace the image tag with your image tag\n### \ndocker   run -d               \\\n        --name 002-container \\\n        -p 8888:8888         \\\n        nirgeier/docker-labs-002\n\n### Check that the container is working as expected\ndocker logs 002-container         \n</code></pre></li> </ul>"},{"location":"002-DockerFile/#09-test-the-server","title":"09. Test the server","text":"<ul> <li> <p>Test the server that he is running on docker.</p> <pre><code># Test the server that he is running on docker\ncurl -s localhost:8888\n\n### ExpectedOutput:\nServer is running.!! You asked for: /\n</code></pre> </li> </ul>"},{"location":"002-DockerFile/#10-clean-up","title":"10. Clean up","text":"<ul> <li>Stop and remove the container     <pre><code># Stop the container\n# If we used --rm the container should remove itself\ndocker stop 002-container\n\n# If not used --rm - remove the container\ndocker rm 002-container\n</code></pre></li> </ul>"},{"location":"003-DockerFile-MultiStage/","title":"003-DockerFile-MultiStage","text":""},{"location":"003-DockerFile-MultiStage/#lab-writing-docker-multi-stage-build","title":"Lab - Writing Docker multi-stage build","text":"<ul> <li>In this lab we will learn how to write a multi-stage Docker file</li> <li>A multistage build allows you to use multiple images to build a final product. </li> <li>In a multistage build, you have a single Dockerfile which build up multiple images inside it to help build the final image.</li> </ul>"},{"location":"003-DockerFile-MultiStage/#01-create-multi-stage-docker-file","title":"01. Create multi-stage docker file","text":"<ul> <li>The first step is to create a Dockerfile.</li> <li>Later on we will pass build time arguments to this file to build the desired image</li> <li><code>Dockerfile</code> <pre><code># Get the value of the desired image to build\nARG     BASE_IMG=curl\n\n# Build the base image \nFROM    alpine AS base_image\n\n# Add some content to the 2nd image\nFROM    base_image  AS build-curl\nRUN     echo -e \"This file is from curl image\" &gt; image.txt\n\n# Add some content to the 3rd image\nFROM    base_image  AS build-bash\nRUN     echo -e \"This file is from bash image\" &gt; image.txt\n\n# Build the desired image\nFROM    build-${BASE_IMG}\n\n# We can use the FROM command as we see in the previous line or use the\n# We can also use image index instead\n# COPY  --from=build-${BASE_IMG} image.txt . to copy a specific content\nRUN     cat image.txt\nCMD     [\"cat\", \"image.txt\"]\n</code></pre></li> </ul>"},{"location":"003-DockerFile-MultiStage/#02-build-the-desired-images","title":"02. Build the desired images","text":"<ul> <li>We will use the following script to build multiple images and to test the results     <pre><code>#!/bin/bash -x\n\n# Build The curl based image (no-cache)\ndocker build --build-arg BASE_IMG=curl --no-cache -t curl1 .\n\n# Build The bash based image (no-cache)\ndocker build --build-arg BASE_IMG=bash --no-cache -t bash1 .\n\n### Build with cache\necho -e \"\"\necho -e \"---------------------------------\"\necho -e \"\"\n# Build The curl based image (with cache)\ndocker build --build-arg BASE_IMG=curl -t curl2 .\n\n# Build The bash based image (with cache)\ndocker build --build-arg BASE_IMG=bash -t bash2 .\n</code></pre></li> </ul>"},{"location":"003-DockerFile-MultiStage/#03-test-the-images","title":"03. Test the images","text":"<ul> <li> <p>We will now test the 4 images we build perviously     <pre><code># Debug mode\nset -x\n\n# Test the output images\ndocker run curl1\ndocker run curl2\ndocker run bash1\ndocker run bash2\n</code></pre></p> </li> <li> <p>You should see output similar to this one:     <pre><code>+ docker run curl1\nThis file is from curl image\n+ docker run curl2\nThis file is from curl image\n+ docker run bash1\nThis file is from bash image\n+ docker run bash2\nThis file is from bash image\n</code></pre></p> </li> </ul>"},{"location":"003-DockerFile-MultiStage/#04-quiz","title":"04. Quiz","text":"<ul> <li>What will be the results of this docker file?</li> <li>Try to answer and then build the following <code>Dockerfile</code> to see the results         <pre><code># Build the base image\nFROM    alpine AS base_image\n\n# Add some packages to the base image\nFROM    base_image  AS build-curl\nRUN     echo -e \"\\033[1;33mThis file is from curl image\\033[0m\" &gt; image.txt\n\n# Add some packages to the base image\nFROM    base_image  AS build-bash\nRUN     echo -e \"\\033[1;32mThis file is from bash image\\033[0m\" &gt; image.txt\n\n#   Build the desired image\nFROM    build-curl\nCOPY    --from=2 image.txt .\nRUN cat image.txt\nCMD [\"cat\", \"image.txt\"]\n</code></pre></li> <li> <p>Test your answer with the following command</p> <pre><code>docker build -f Dockerfile2 .\n</code></pre> </li> </ul>"},{"location":"003-DockerFile-MultiStage/#05-build-a-specific-target","title":"05. Build a specific target","text":"<ul> <li>We can build our specific image and stop at the desired stage</li> <li> <p>In other words we don\u2019t need to build all the images within the docker file</p> <pre><code>docker build --target build-curl -f Dockerfile2 .\n</code></pre> </li> </ul>"},{"location":"003-DockerFile-MultiStage/#06-in-class-exercise","title":"06. In-Class Exercise","text":"<ul> <li>Create a <code>multi-stage</code> docker file that will build 2 images</li> <li>The first image will be based on <code>alpine</code> and will create a file named <code>alpine.txt</code> with the content: <code>This is alpine image</code></li> <li>The second image will be based on <code>node</code> and will create a file named <code>node.txt</code> with the content: <code>This is node image</code></li> <li>The final image should be based on <code>alpine</code> and should copy the files which you created from the previous stages and display their content when the container will run.</li> <li>Hint: Use the <code>COPY --from=</code> command to copy files from previous stages</li> </ul> Solution  ### Dockerfile Solution  Create a file named `Dockerfile-exercise`:  <pre><code># First stage: Alpine image\nFROM  alpine AS alpine-stage\nRUN   echo \"This is alpine image\" &gt; alpine.txt\n\n# Second stage: Node image\nFROM  node AS node-stage\nRUN   echo \"This is node image\" &gt; node.txt\n\n# Final stage: Alpine with files from previous stages\nFROM  alpine\nCOPY  --from=alpine-stage alpine.txt  .\nCOPY  --from=node-stage node.txt      .\n\n# Run the command to display contents\nCMD   cat alpine.txt &amp;&amp; cat node.txt\n</code></pre>  ### Build and Test  Build the image:  <pre><code>docker build -f Dockerfile-exercise -t exercise-solution .\n</code></pre>  Run the container:  <pre><code>docker run exercise-solution\n</code></pre>  Expected output:  <pre><code>This is alpine image\nThis is node image\n</code></pre>  ### Explanation  1. **First Stage (alpine-stage)**: Based on `alpine`, creates `alpine.txt` with the required content 2. **Second Stage (node-stage)**: Based on `node`, creates `node.txt` with the required content 3. **Final Stage**: Based on `alpine` (lightweight), copies both files from previous stages using `COPY --from=` and displays their content when run"},{"location":"004-LocalRegistry/","title":"Index","text":""},{"location":"004-LocalRegistry/#docker-hands-on-repository","title":"Docker Hands-on Repository","text":"<ul> <li>A collection of Hands-on Docker labs.</li> <li>Each lab is a standalone lab and does not require to complete the previous labs.</li> </ul>"},{"location":"004-LocalRegistry/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Docker installed</li> <li>Dockerfile knowledge </li> <li>DockerHub account</li> </ul>"},{"location":"004-LocalRegistry/#lab-setup-basic-local-docker-registry","title":"Lab: Setup Basic Local Docker Registry","text":"<ul> <li>In this lab we will learn how to create a local Docker registry.</li> <li>In this lab we will learn how to push and pull images from the local registry.</li> <li>in this lab we will be using the default configuration, but of course you can change it as you wish.</li> <li>Configuration docs: https://docs.docker.com/registry/configuration</li> </ul> <ul> <li>01. Create a basic local registry</li> <li>02. Prepare the local images</li> <li>02.01. Download busybox image</li> <li>02.01. Tag the image with the local registry prefix</li> <li>02.02. Push the image to the local registry</li> <li>03. Test local images</li> </ul>"},{"location":"004-LocalRegistry/#01-create-a-basic-local-registry","title":"01. Create a basic local registry","text":"<ul> <li>The first step is to create a local registry.</li> <li>For this we will use the <code>docker run</code> command with the docker <code>registry</code>- https://hub.docker.com/_/registry image.</li> </ul> <pre><code># Run the registry container\ndocker  run                     \\\n        -d                      \\\n        -p 5000:5000            \\\n        --restart always        \\\n        --name registry         \\\n        registry:latest\n</code></pre>"},{"location":"004-LocalRegistry/#02-prepare-the-local-images","title":"02. Prepare the local images","text":"<ul> <li>We will download the images from DockerHub and push them to the local registry.</li> </ul>"},{"location":"004-LocalRegistry/#0201-download-busybox-image","title":"02.01. Download busybox image","text":"<pre><code># download busybox image from docker-hub\ndocker pull busybox\n</code></pre>"},{"location":"004-LocalRegistry/#0201-tag-the-image-with-the-local-registry-prefix","title":"02.01. Tag the image with the local registry prefix","text":"<pre><code># Tag the busybox image with the local registry prefix\ndocker tag busybox localhost:5000/busybox\n</code></pre>"},{"location":"004-LocalRegistry/#0202-push-the-image-to-the-local-registry","title":"02.02. Push the image to the local registry","text":"<pre><code># Once we have the appropriate tag, we can push the image to the local registry\ndocker push localhost:5000/busybox\n</code></pre>"},{"location":"004-LocalRegistry/#03-test-local-images","title":"03. Test local images","text":"<pre><code># List all local repositories\ncurl -X GET http://localhost:5000/v2/_catalog\n\n# List all tags for a repository\ncurl -X GET https://myregistry:5000/v2/ubuntu/tags/list\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/","title":"Index","text":""},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#docker-hands-on-repository","title":"Docker Hands-on Repository","text":"<ul> <li>A collection of Hands-on Docker labs.</li> <li>Each lab is a standalone lab and does not require to complete the previous labs.</li> </ul>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#ctrl-click-to-open-in-new-window","title":"CTRL + click to open in new window","text":""},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Docker installation</li> </ul>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#lab-0201-setup-advanced-local-docker-registry","title":"Lab 0201. Setup Advanced Local Docker Registry","text":"<ul> <li>In the previous lab we created a basic local registry.</li> <li>In this lab we will create a local registry with advanced features.</li> <li>The local registry will be accessible from the host machine and will be build upon</li> <li>Nginx</li> <li>Docker registry image</li> <li>Docker compose</li> <li>Secured with certificates</li> </ul>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-01-create-registry-directories","title":"Step 01. Create Registry Directories","text":"<pre><code># Create the required directories for the advanced configuration\nmkdir -p                      \\\n      registry/nginx          \\\n      registry/nginx/conf.d   \\\n      registry/nginx/ssl      \\\n      registry/auth\necho 'Docker rocks !!!' | docker run -it -a stdin alpine cat -\n# On GCP shell we cont have tree by default, so lets install it\nsudo apt install -y tree\n\n# Verify that the directories were created\ncd registry &amp;&amp; tree\n\n# We should see the following structure\n.\n\u251c\u2500\u2500 auth\n\u2514\u2500\u2500 nginx\n    \u251c\u2500\u2500 conf.d\n    \u2514\u2500\u2500 ssl\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-02-create-docker-compose-for-the-registry-services","title":"Step 02. Create Docker-Compose for the registry services","text":"<pre><code># Create the docker-compose file in the registry directory\ncat &lt;&lt; EOF &gt; registry/docker-compose.yml\nversion: '3'\nservices:\n  # The docker registry service\n  registry:\n    # The name of the container\n    container_name: registry\n\n    # The registry image which we will use\n    image: registry:2\n    # Ensures to start Docker Registry\n    restart: always\n    # The port on which the registry will be listen on\n    ports:\n    - \"5000:5000\"\n    # Registry environment variables\n\n    # The service will mount the docker volume \"registrydata\" and\n    # the local directory \"auth\",\n    # along with its authentication file \"registry.passwd\".\n    environment:\n      REGISTRY_AUTH: htpasswd\n      REGISTRY_AUTH_HTPASSWD_REALM: Registry-Realm\n      REGISTRY_AUTH_HTPASSWD_PATH: /auth/registry.passwd\n      REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /data\n\n    # mounted volumes\n    volumes:\n      - registrydata:/data\n      - ./auth:/auth\n\n    # The desired network\n    networks:\n      - bridge_network\n\n  #### Nginx Service\n  nginx:\n\n    # The name of the container\n    container_name: nginx\n\n    # We depends on the registry service\n    depends_on:\n      - registry\n\n    # nginx image\n    image: nginx:alpine\n    container_name: nginx\n    restart: unless-stopped\n    tty: true\n\n    # The desired listen ports\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n\n    # The mounted volumes for the configuration files\n    # Mount the local directory for virtual configuration (conf.d)\n    # and SSL certificates (ssl).\n    volumes:\n      - ./nginx/conf.d/:/etc/nginx/conf.d/\n      - ./nginx/ssl/:/etc/nginx/ssl/\n\n    # The desired network\n    networks:\n      - bridge_network\n\n# Docker Networks for those services\nnetworks:\n  # Define a bridge network names \"bridge_network\"\n  bridge_network:\n    driver: bridge\n\n# Define custom volume for the registry data named \"registrydata\"\n# using the \"local\" driver\nvolumes:\n  registrydata:\n    driver: local\n\nEOF\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-03-create-the-nginx-configuration-file","title":"Step 03. Create the Nginx configuration file","text":"<ul> <li>The next step is configuring a Nginx virtual host for the Nginx service.</li> <li>Create a new virtual host file named <code>registry.conf</code> under <code>nginx/conf.d/</code></li> </ul> <pre><code># Create a new virtual host file for our nginx service\ncat &lt;&lt; EOF &gt; nginx/conf.d/registry.conf\nupstream docker-registry {\n  server registry:5000;\n}\n\nserver {\n  listen      443 ssl http2;\n\n  # SSL\n  ssl on;\n  ssl_certificate /etc/nginx/ssl/registry.crt;\n  ssl_certificate_key /etc/nginx/ssl/registry.key;\n\n  # disable any limits to avoid HTTP 413 for large image uploads\n  # We will use `/etc/nginx/conf.d/additional.conf` as well later below\n  client_max_body_size 0;\n\n  # required to avoid HTTP 411: see Issue #1486 (https://github.com/docker/docker/issues/1486)\n  chunked_transfer_encoding on;\n\n  location /v2/ {\n    # Do not allow connections from docker 1.5 and earlier\n    # docker pre-1.6.0 did not properly set the user agent on ping, catch \"Go *\" user agents\n    if (\\$http_user_agent ~ \"^(docker\\/1\\.(3|4|5(?!\\.[0-9]-dev))|Go ).*$\" ) {\n      return 404;\n    }\n\n    # To add basic authentication to v2 use auth_basic setting plus add_header\n    # auth_basic \"registry.localhost\";\n    # auth_basic_user_file /etc/nginx/conf.d/registry.password;\n    # add_header 'Docker-Distribution-Api-Version' 'registry/2.0' always;\n\n    proxy_pass                          http://docker-registry;\n    proxy_set_header  Host              \\$http_host;   # required for docker client's sake\n    proxy_set_header  X-Real-IP         \\$remote_addr; # pass on real client's IP\n    proxy_set_header  X-Forwarded-For   \\$proxy_add_x_forwarded_for;\n    proxy_set_header  X-Forwarded-Proto \\$scheme;\n    proxy_read_timeout                  900;\n  }\n}\nEOF\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-04-increase-nginx-file-upload-size","title":"Step 04. Increase Nginx File Upload Size","text":"<ul> <li>By default, Nginx limits the file upload size to <code>1MB</code>.</li> <li>Most Docker images exceed <code>1MB</code> in size so we will increase the maximum file size on our Nginx service to <code>2GB</code>.</li> </ul> <pre><code># Increase the maximum file upload size to 2GB\necho  'client_max_body_size 2G;' &gt; registry/nginx/conf.d/additional.conf\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-05-configure-ssl-certificate","title":"Step 05. Configure SSL Certificate","text":"<ul> <li>For our secured authentication we will use self-signed certificates.</li> <li>lets generate the certificate and key files</li> </ul> <pre><code># Generate the self-signed certificate\nopenssl \\\n    req                     \\\n    -x509                   \\\n    -sha256                 \\\n    -newkey   rsa:4096      \\\n    -days     3650          \\\n    -nodes                  \\\n    -subj \"/CN=localhost\"   \\\n    -addext \"subjectAltName=DNS:localhost,DNS:localhost,IP:127.0.0.1\" \\\n    -keyout   registry/nginx/ssl/registry.key  \\\n    -out      registry/nginx/ssl/registry.crt\n\n\n# Verify the certificate and the key\nopenssl x509 -text  -noout -in registry/nginx/ssl/registry.crt\n\n# Verify that the key and the certificate matches\nopenssl rsa -check -noout -in registry/nginx/ssl/registry.key\n\n# We search a matching certificate and key md5 fingerprint\necho 'registry.key Checksum is: ' \\\n      $(openssl rsa -modulus -noout -in registry/nginx/ssl/registry.key | openssl md5)\n\necho 'registry.crt Checksum is: '  \\\n      $(openssl x509 -modulus -noout -in registry/nginx/ssl/registry.crt | openssl md5)\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-06-configure-authentication","title":"Step 06. Configure authentication","text":"<ul> <li>There are several ways to generate a password file for the registry.</li> </ul> <p>#### Option 01. using <code>htpasswd</code></p> <ul> <li>The <code>htpasswd</code> utility is a simple utility that can be used to create a password file.</li> <li>If you don\u2019t have this installed, first we need to instal it if is not installed.</li> </ul> <pre><code># install htpasswd\nsudo apt install -y apache2-utils\n\n# Now generate the password file\n# Note: You will need to enter the password twice\n#       `-c` - Create a new file.\n#       -B   - Force bcrypt encryption of the password (very secure).\nhtpasswd -Bc registry/nginx/ssl/registry.passwd $USER\n</code></pre> <p>#### Option 02. using <code>openssl</code></p> <pre><code># Generate a random password\nprintf \\\n        \"USER:$(openssl passwd -crypt PASSWORD)\\n\" &gt;&gt; \\\n        registry/nginx/ssl/registry.passwd\n\n# Verify that the password was generated\ncat registry/nginx/ssl/registry.passwd\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-07-add-the-root-ca-certificate","title":"Step 07. Add the Root CA Certificate","text":"<ul> <li>Next step is to add the Root CA certificate to Docker</li> <li>We will place certificates under the docker certificates folder for our domain</li> </ul> <pre><code># Create the required folders for the certificate\nsudo mkdir -p /etc/docker/certs.d/registry.codewizard.co.il\n\n# Copy the certificate to the docker certificates folder\nsudo cp \\\n        registry/nginx/ssl/registry.crt \\\n        /etc/docker/certs.d/registry.codewizard.co.il/rootCA.crt\n\n# Create the second folder for the certificate\nsudo mkdir -p /etc/docker/certs.d/codewizard.co.il\n\n# Copy the certificate to the second certificates folder\nsudo cp \\\n        registry/nginx/ssl/registry.crt \\\n        /etc/docker/certs.d/codewizard.co.il/rootCA.crt\n\n# Copy the certificate into /usr/share/ca-certificate/extra\nsudo mkdir -p /usr/local/share/ca-certificates/\nsudo cp \\\n        registry/nginx/ssl/registry.crt \\\n        /usr/local/share/ca-certificates/rootCA.crt\n</code></pre> <ul> <li>Once we have the certificates in place we can add them to the list of trusted certificates.</li> </ul> <pre><code># Add the certificate to the list of trusted certificates\nsudo update-ca-certificates\n</code></pre>"},{"location":"004-LocalRegistry/AdvancedLocalRegistry/#step-08-restart-docker-registry","title":"Step 08. Restart Docker registry","text":"<p>/etc/docker/daemon.json</p>"},{"location":"005-DockerCompose/","title":"Index","text":""},{"location":"005-DockerCompose/#lab-005-docker-compose-wordpress-mariadb","title":"Lab 005: Docker Compose - WordPress &amp; MariaDB","text":"<p>This lab demonstrates how to use Docker Compose to orchestrate a simple multi-container application: WordPress with a MariaDB database backend.</p>"},{"location":"005-DockerCompose/#overview","title":"Overview","text":"<ul> <li> <p>The provided <code>docker-compose.yaml</code> file defines two main services:</p> </li> <li> <p>db: Runs a MariaDB database (can be switched to MySQL if desired).</p> </li> <li> <p>wordpress: Runs the latest WordPress application, connected to the database.</p> </li> <li> <p>A named volume <code>db_data</code> is used to persist database data.</p> </li> </ul>"},{"location":"005-DockerCompose/#docker-composeyaml-breakdown","title":"docker-compose.yaml Breakdown","text":"<ul> <li>db service</li> <li>Uses the <code>mariadb:10.6.4-focal</code> image (or optionally MySQL).</li> <li>Sets up environment variables for root password, database, user, and password.</li> <li>Persists data in a Docker volume.</li> <li> <p>Exposes ports 3306 and 33060 (internal only).</p> </li> <li> <p>wordpress service</p> </li> <li>Uses the latest WordPress image.</li> <li>Maps port 80 on the host to port 80 in the container.</li> <li> <p>Configures environment variables to connect to the database.</p> </li> <li> <p>volumes</p> </li> <li><code>db_data</code>: Persists MariaDB data between container restarts.</li> </ul>"},{"location":"005-DockerCompose/#bonus-demo","title":"Bonus Demo","text":"<ul> <li>I prepared a demo of this lab, which you can view on KillerCoda: Portainder Demo.</li> <li>The demo is showcases for setting and running multuple containers using Docker Compose</li> <li>The demo is available on KillerCoda.</li> </ul>"},{"location":"005-DockerCompose/#how-to-run-the-lab","title":"How to Run the Lab","text":"<ol> <li> <p>Navigate to the lab directory: <pre><code>cd Labs/005-DockerCompose\n</code></pre></p> </li> <li> <p>Start the services: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>This will pull the required images (if not already present) and start both the database and WordPress containers in detached mode.</p> </li> <li> <p>Access WordPress:</p> </li> <li>Open your browser and go to http://localhost</li> <li> <p>Complete the WordPress setup wizard.</p> </li> <li> <p>Stop the services: <pre><code>docker compose down\n</code></pre>    This will stop and remove the containers, but the database data will persist in the <code>db_data</code> volume.</p> </li> </ol>"},{"location":"005-DockerCompose/#notes","title":"Notes","text":"<ul> <li>To use MySQL instead of MariaDB, uncomment the relevant line in the compose file and comment out the MariaDB image line.</li> <li>The database credentials are set for demonstration purposes. For production, use secure passwords.</li> <li>The <code>db</code> service is only accessible to the <code>wordpress</code> service (not exposed to the host).</li> </ul>"},{"location":"005-DockerCompose/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you encounter port conflicts, ensure nothing else is running on port 80.</li> <li>To view logs for a service:   <pre><code>docker compose logs wordpress\ndocker compose logs db\n</code></pre></li> </ul> <p>This lab is part of the DockerLabs series. See other labs for more Docker scenarios and hands-on exercises.</p>"},{"location":"006-DockerCompose-env/","title":"Index","text":""},{"location":"006-DockerCompose-env/#multi-environment-docker-compose-setup","title":"Multi-Environment Docker Compose Setup","text":"<ul> <li>A comprehensive example of structuring Docker Compose files for multiple environments</li> <li>Demonstrates environment-specific overrides and configuration management</li> <li>Each environment is fully isolated with its own configuration and services</li> </ul>"},{"location":"006-DockerCompose-env/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Docker installed</li> <li>Docker Compose knowledge</li> <li>Basic understanding of environment variables</li> </ul> <ul> <li>Overview</li> <li>Project Structure</li> <li>Step 01 - Understanding the Base Configuration</li> <li>Step 02 - Development Environment</li> <li>Step 03 - Production Environment</li> <li>Step 04 - Environment Variables</li> <li>Shared Variables (<code>.env</code>)</li> <li>Development Variables (<code>.env.dev</code>)</li> <li>Production Variables (<code>.env.prod</code>)</li> <li>Step 05 - Quick Start with Scripts</li> <li>Using the run.sh Script</li> <li>Step 06 - Manual Commands</li> <li>Start Specific Environment</li> <li>Stop Services</li> <li>View Logs</li> <li>Scale Services (Production)</li> <li>Step 07 - Testing the Setup</li> <li>Interactive Demo</li> <li>Manual Testing</li> <li>Step 08 - Clean Up</li> <li>Best Practices</li> <li>Troubleshooting</li> <li>Common Issues</li> <li>Debugging Commands</li> <li>Environment-Specific Notes</li> </ul>"},{"location":"006-DockerCompose-env/#overview","title":"Overview","text":"<p>This lab demonstrates how to structure Docker Compose files for multiple environments using:</p> <ul> <li>Base Configuration: Common services shared across environments</li> <li>Environment Overrides: Specific configurations for development and production</li> <li>Environment Variables: Centralized configuration management</li> <li>Utility Scripts: Easy environment management</li> </ul>"},{"location":"006-DockerCompose-env/#project-structure","title":"Project Structure","text":"<pre><code>Labs/006-DockerCompose-env/\n\u251c\u2500\u2500 docker-compose.yml          # Base services configuration\n\u251c\u2500\u2500 docker-compose.dev.yml      # Development overrides\n\u251c\u2500\u2500 docker-compose.prod.yml     # Production overrides\n\u251c\u2500\u2500 .env                        # Shared environment variables\n\u251c\u2500\u2500 .env.dev                    # Development-specific variables\n\u251c\u2500\u2500 .env.prod                   # Production-specific variables\n\u251c\u2500\u2500 README.md                   # This documentation\n\u251c\u2500\u2500 run.sh                      # Bash script for environment management\n\u251c\u2500\u2500 demo.sh                     # Interactive demonstration\n\u251c\u2500\u2500 init.sql                    # Database initialization\n\u251c\u2500\u2500 html/\n\u2502   \u2514\u2500\u2500 index.html             # Sample web application\n\u2514\u2500\u2500 api/\n    \u251c\u2500\u2500 package.json           # Node.js API dependencies\n    \u2514\u2500\u2500 server.js              # Sample API server\n</code></pre>"},{"location":"006-DockerCompose-env/#step-01-understanding-the-base-configuration","title":"Step 01 - Understanding the Base Configuration","text":"<p>The <code>docker-compose.yml</code> file contains the core service definitions that are common across all environments:</p> <ul> <li>Web Service: Nginx web server</li> <li>API Service: Node.js backend application  </li> <li>Database Service: PostgreSQL database</li> <li>Cache Service: Redis caching layer</li> </ul> <p>All services use environment variables with default values using the <code>${VARIABLE:-default}</code> syntax for flexibility.</p>"},{"location":"006-DockerCompose-env/#step-02-development-environment","title":"Step 02 - Development Environment","text":"<p>The development environment (<code>docker-compose.dev.yml</code>) provides developer-friendly features:</p> <pre><code># Start development environment\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml up -d\n</code></pre> <p>Development Features:</p> <ul> <li>Hot reload enabled for API service (nodemon)</li> <li>Debug ports exposed (9229 for Node.js debugging)</li> <li>Additional development tools:</li> <li>Adminer for database management</li> <li>MailCatcher for email testing</li> <li>Read-write volumes for live code editing</li> <li>Detailed logging enabled</li> <li>Non-standard ports to avoid conflicts (8000, 3001, 5433, 6380)</li> </ul> <p>Development Services Access:</p> <ul> <li>Web Application: <code>http://localhost:8000</code></li> <li>API: <code>http://localhost:3001</code></li> <li>Database Admin (Adminer): <code>http://localhost:8080</code></li> <li>Mail Catcher: <code>http://localhost:1080</code></li> </ul>"},{"location":"006-DockerCompose-env/#step-03-production-environment","title":"Step 03 - Production Environment","text":"<p>The production environment (<code>docker-compose.prod.yml</code>) focuses on performance and security:</p> <pre><code># Start production environment\ndocker-compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml up -d\n</code></pre> <p>Production Features:</p> <ul> <li>Multiple service replicas for high availability</li> <li>Read-only volumes for security</li> <li>Optimized restart policies</li> <li>Structured logging with rotation</li> <li>Monitoring with Prometheus</li> <li>Standard service ports (80, 3000, 5432, 6379)</li> </ul> <p>Production Services Access:</p> <ul> <li>Web Application: <code>http://localhost:80</code></li> <li>API: <code>http://localhost:3000</code></li> <li>Monitoring (Prometheus): <code>http://localhost:9090</code></li> </ul>"},{"location":"006-DockerCompose-env/#step-04-environment-variables","title":"Step 04 - Environment Variables","text":""},{"location":"006-DockerCompose-env/#shared-variables-env","title":"Shared Variables (<code>.env</code>)","text":"<p>Common configuration across all environments:</p> Variable Description <code>APP_NAME</code> Application name for container naming <code>ENVIRONMENT</code> Current environment identifier <code>DB_NAME</code> Database name <code>DB_USER</code> Database user <code>API_SECRET</code> API authentication secret <code>LOG_LEVEL</code> Logging verbosity"},{"location":"006-DockerCompose-env/#development-variables-envdev","title":"Development Variables (<code>.env.dev</code>)","text":"Variable/Setting Description Non-standard ports Avoid conflicts with other services Debug-friendly config Enables debug mode and verbose logging Dev DB credentials Uses development database credentials Enhanced logging More detailed logs for debugging"},{"location":"006-DockerCompose-env/#production-variables-envprod","title":"Production Variables (<code>.env.prod</code>)","text":"Variable/Setting Description Standard service ports Uses standard ports for production Strong, secure passwords Enforces strong credentials Optimized timeouts Sets timeouts suitable for production Security-focused config Enables production security best practices"},{"location":"006-DockerCompose-env/#step-05-quick-start-with-scripts","title":"Step 05 - Quick Start with Scripts","text":""},{"location":"006-DockerCompose-env/#using-the-runsh-script","title":"Using the run.sh Script","text":"<pre><code># Development environment\n./run.sh dev up        # Start development\n./run.sh dev down      # Stop development\n./run.sh dev logs      # View development logs\n./run.sh dev ps        # Show service status\n\n# Production environment\n./run.sh prod up       # Start production\n./run.sh prod down     # Stop production\n./run.sh prod logs     # View production logs\n\n# Help\n./run.sh help          # Show usage information\n</code></pre>"},{"location":"006-DockerCompose-env/#step-06-manual-commands","title":"Step 06 - Manual Commands","text":""},{"location":"006-DockerCompose-env/#start-specific-environment","title":"Start Specific Environment","text":"<pre><code># Development\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml up -d\n\n# Production\ndocker-compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml up -d\n</code></pre>"},{"location":"006-DockerCompose-env/#stop-services","title":"Stop Services","text":"<pre><code># Development\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml down\n\n# Production  \ndocker-compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml down\n</code></pre>"},{"location":"006-DockerCompose-env/#view-logs","title":"View Logs","text":"<pre><code># All services logs\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml logs -f\n\n# Specific service logs\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml logs -f api\n</code></pre>"},{"location":"006-DockerCompose-env/#scale-services-production","title":"Scale Services (Production)","text":"<pre><code># Scale API service to 5 replicas\ndocker-compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml up -d --scale api=5\n</code></pre>"},{"location":"006-DockerCompose-env/#step-07-testing-the-setup","title":"Step 07 - Testing the Setup","text":""},{"location":"006-DockerCompose-env/#interactive-demo","title":"Interactive Demo","text":"<p>Run the complete demonstration:</p> <pre><code># Run the interactive demo\n./demo.sh\n</code></pre> <p>The demo will:</p> <ol> <li>Start development environment</li> <li>Test the application</li> <li>Switch to production environment  </li> <li>Show differences between environments</li> <li>Clean up</li> </ol>"},{"location":"006-DockerCompose-env/#manual-testing","title":"Manual Testing","text":"<pre><code># Start development environment\n./run.sh dev up\n\n# Test the API\ncurl -s http://localhost:3001/health | python3 -m json.tool\n\n# Test the web application\ncurl -s http://localhost:8000\n\n# Check service status\n./run.sh dev ps\n</code></pre>"},{"location":"006-DockerCompose-env/#step-08-clean-up","title":"Step 08 - Clean Up","text":"<pre><code># Stop current environment\n./run.sh dev down     # or ./run.sh prod down\n\n# Complete cleanup (removes volumes)\n./run.sh dev down &amp;&amp; ./run.sh prod down\ndocker system prune -f\n\n# Or manually\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml down -v\ndocker-compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml down -v\n</code></pre>"},{"location":"006-DockerCompose-env/#best-practices","title":"Best Practices","text":"<ol> <li>Environment Separation: Clear separation between dev, staging, and production configurations</li> <li>Security: Different secrets and passwords per environment</li> <li>Scalability: Production setup with multiple replicas and monitoring</li> <li>Development Experience: Hot reload, debugging ports, and development tools</li> <li>Configuration Management: Centralized environment variable management</li> <li>Volume Management: Read-only volumes in production, read-write in development</li> <li>Logging: Environment-appropriate logging levels and rotation</li> <li>Networking: Consistent network setup across environments</li> </ol>"},{"location":"006-DockerCompose-env/#troubleshooting","title":"Troubleshooting","text":""},{"location":"006-DockerCompose-env/#common-issues","title":"Common Issues","text":"<ul> <li>Port conflicts: Ensure no other services are using the same ports</li> <li>Environment variables: Verify all required variables are set in <code>.env</code> files</li> <li>Docker daemon: Ensure Docker is running and accessible</li> </ul>"},{"location":"006-DockerCompose-env/#debugging-commands","title":"Debugging Commands","text":"<pre><code># Check service logs\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml logs service_name\n\n# Check service status\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml ps\n\n# Inspect container\ndocker inspect container_name\n\n# Execute command in container\ndocker-compose --env-file .env.dev -f docker-compose.yml -f docker-compose.dev.yml exec service_name bash\n</code></pre>"},{"location":"006-DockerCompose-env/#environment-specific-notes","title":"Environment-Specific Notes","text":"Environment/Aspect Notes Development Services may take longer to start due to volume mounts Production Services use restart policies and may auto-restart on failure Networking All services communicate through Docker networks"},{"location":"009-multistage/","title":"Docker Multistage Build","text":"<ul> <li><code>Docker multistage builds</code> allow you to use multiple <code>FROM</code> statements in your Dockerfile.</li> <li><code>Docker multistage builds</code> is used for copying artifacts from one stage to another. </li> <li><code>Docker multistage builds</code> helps create smaller, more secure images by separating build dependencies from the final runtime image.</li> </ul>"},{"location":"009-multistage/#why-use-multistage-builds","title":"Why Use Multistage Builds?","text":"<ul> <li>Reduce image size:</li> <li>Use a minimal base image for the final stage.</li> <li>Only copy necessary files to the final image.</li> <li>Improve security:</li> <li>Exclude build tools and secrets from the runtime image.</li> <li>Limit the attack surface by using a smaller image.</li> <li>Use a non-root user in the final image.</li> <li>Simplify CI/CD pipelines:</li> <li>Combine build, test, and deploy stages in a single Dockerfile.</li> <li>Use different base images for different stages (e.g., <code>golang</code>, <code>node</code>, <code>python</code>).</li> <li>Easier debugging:</li> <li>Each stage can be built and tested independently.</li> <li>Use named stages for better readability and maintainability.</li> <li>Faster builds:</li> <li>Leverage Docker\u2019s caching mechanism to speed up builds.</li> <li>Only rebuild stages that have changed.</li> <li>Cleaner Dockerfiles:</li> <li>Separate concerns by using multiple stages.</li> <li>Avoid cluttering the final image with unnecessary files.</li> <li>Better caching:</li> <li>Docker caches each stage, so only changed stages need to be rebuilt.</li> <li>Easier to manage dependencies:</li> <li>Install build dependencies in one stage and runtime dependencies in another.</li> <li>Use different base images for different stages (e.g., <code>golang</code>, <code>node</code>, <code>python</code>).</li> <li>This allows you to use the best image for each stage without bloating the final image.</li> <li>Simplify Dockerfiles: </li> <li>No need for manual cleanup of build dependencies.</li> <li>Easier to read and maintain.</li> <li>Use comments to explain each stage\u2019s purpose.</li> <li>Use meaningful names for stages to clarify their roles.</li> <li>Better caching:</li> <li>Docker caches each stage, so only changed stages need to be rebuilt.</li> </ul>"},{"location":"009-multistage/#basic-example","title":"Basic Example","text":"<p>Suppose you have a simple Go application:</p> <p>Dockerfile: <pre><code># Build stage\nFROM golang:1.21 AS builder\nWORKDIR /app\nCOPY . .\nRUN go build -o myapp\n\n# Final stage\nFROM alpine:latest\nWORKDIR /app\nCOPY --from=builder /app/myapp ./\nCMD [\"./myapp\"]\n</code></pre></p> <p>How it works: - The first stage (<code>builder</code>) compiles the Go app. - The second stage copies only the compiled binary into a minimal Alpine image.</p>"},{"location":"009-multistage/#nodejs-example","title":"Node.js Example","text":"<pre><code># Build stage\nFROM node:20 AS build\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM node:20-slim\nWORKDIR /app\nCOPY --from=build /app/dist ./dist\nCOPY --from=build /app/package*.json ./\nRUN npm install --only=production\nCMD [\"node\", \"dist/index.js\"]\n</code></pre>"},{"location":"009-multistage/#advanced-multistage-build-examples","title":"Advanced Multistage Build Examples","text":""},{"location":"009-multistage/#1-multi-artifact-build-frontend-backend","title":"1. Multi-Artifact Build (Frontend + Backend)","text":"<pre><code># Build frontend\nFROM node:20 AS frontend-build\nWORKDIR /frontend\nCOPY frontend/package*.json ./\nRUN npm install\nCOPY frontend/ .\nRUN npm run build\n\n# Build backend\nFROM golang:1.21 AS backend-build\nWORKDIR /backend\nCOPY backend/go.mod backend/go.sum ./\nRUN go mod download\nCOPY backend/ .\nRUN go build -o app\n\n# Final image\nFROM alpine:latest\nWORKDIR /app\nCOPY --from=backend-build /backend/app ./\nCOPY --from=frontend-build /frontend/dist ./public\nCMD [\"./app\"]\n</code></pre>"},{"location":"009-multistage/#2-test-lint-and-build-stages","title":"2. Test, Lint, and Build Stages","text":"<pre><code># Install dependencies and run tests\nFROM node:20 AS test\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm test\n\n# Lint stage\nFROM test AS lint\nRUN npm run lint\n\n# Build stage\nFROM test AS build\nRUN npm run build\n\n# Production image\nFROM node:20-slim\nWORKDIR /app\nCOPY --from=build /app/dist ./dist\nCOPY --from=build /app/package*.json ./\nRUN npm ci --only=production\nCMD [\"node\", \"dist/index.js\"]\n</code></pre>"},{"location":"009-multistage/#3-using-a-custom-build-tool-eg-maven-for-java","title":"3. Using a Custom Build Tool (e.g., Maven for Java)","text":"<pre><code># Build with Maven\nFROM maven:3.9-eclipse-temurin-21 AS build\nWORKDIR /app\nCOPY pom.xml .\nCOPY src ./src\nRUN mvn clean package -DskipTests\n\n# Final image with JRE only\nFROM eclipse-temurin:21-jre\nWORKDIR /app\nCOPY --from=build /app/target/app.jar ./app.jar\nCMD [\"java\", \"-jar\", \"app.jar\"]\n</code></pre> <ul> <li> <p>These advanced examples show how to:</p> </li> <li> <p>Build and combine multiple artifacts (frontend + backend)</p> </li> <li>Add test and lint stages for better CI/CD</li> <li>Use language-specific build tools and copy only the final artifact</li> </ul>"},{"location":"009-multistage/#tips","title":"Tips","text":"<ul> <li>Name your stages for clarity: <code>FROM node:20 AS build</code>.</li> <li>Use <code>.dockerignore</code> to exclude unnecessary files from the build context.</li> <li>You can have as many stages as needed.</li> </ul>"},{"location":"009-multistage/#references","title":"References","text":"<ul> <li>Docker Docs: Multistage Builds</li> </ul>"},{"location":"010-DockerCompose/READEM/","title":"Docker Compose Lab","text":"<p>This lab demonstrates how to use Docker Compose to manage multi-container Docker applications.</p>"},{"location":"010-DockerCompose/READEM/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker installed</li> <li>Docker Compose installed</li> </ul>"},{"location":"010-DockerCompose/READEM/#common-docker-compose-commands","title":"Common Docker Compose Commands","text":"Command Description <code>docker-compose up</code> Start all services defined in <code>docker-compose.yaml</code> in the foreground. <code>docker-compose up -d</code> Start all services in detached mode (in the background). <code>docker-compose down</code> Stop and remove all running containers defined in the Compose file. <code>docker-compose logs</code> Show logs for all services. <code>docker-compose logs &lt;service&gt;</code> Show logs for a specific service. <code>docker-compose ps</code> List containers managed by this Compose project. <code>docker-compose exec &lt;service&gt; &lt;command&gt;</code> Run a command in a running service container (e.g., <code>docker-compose exec web bash</code>). <code>docker-compose build</code> Build or rebuild services."},{"location":"010-DockerCompose/READEM/#example","title":"Example","text":"<p>To start the application:</p> <pre><code>docker-compose up -d\n</code></pre> <p>To stop and clean up:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"011-bake/","title":"Index","text":""},{"location":"011-bake/#docker-bake","title":"Docker Bake","text":""},{"location":"011-bake/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1. Introduction</li> <li>What is Docker <code>Docker Bake</code>?</li> <li>What is Docker <code>BuildKit</code>?</li> <li>Key Features</li> <li>Comparison: Docker Bake vs Docker Compose</li> <li>Docker Bake syntax</li> <li>Common Commands</li> <li>Advanced Features</li> <li>Multi-Stage Builds with Matrix</li> <li>Build Secrets</li> <li>Cache Configuration / Build Caching</li> <li>Cache Configuration / Build Caching Workflow</li> <li>Target Inheritance</li> </ul>"},{"location":"011-bake/#1-introduction","title":"1. Introduction","text":""},{"location":"011-bake/#what-is-docker-docker-bake","title":"What is Docker <code>Docker Bake</code>?","text":"<ul> <li> <p>\ud83d\udc4d <code>Docker Bake</code> is a feature of <code>BuildKit</code> / <code>Docker Buildx</code> that allows you    to define and orchestrate complex builds using a high-level build tool that uses to build Docker images defined in configuration files.</p> </li> <li> <p>\ud83d\udc4d <code>Docker Bake</code> is written in a declarative language (<code>HCL</code>, <code>JSON</code>, or <code>YAML</code>). </p> </li> <li> <p>\ud83d\udc4d <code>Docker Bake</code> is designed for building multiple images or targets concurrently, making it ideal for monorepos, microservices, or any project with several <code>Dockerfiles</code>.</p> </li> <li> <p>\ud83d\udc4d <code>Docker Bake</code> extends beyond single <code>Dockerfile</code>s to support complex build scenarios with multiple targets, platforms, and configurations.</p> </li> <li> <p>\ud83d\udc4d <code>Docker Bake</code> is designed for CI/CD pipelines, multi-platform builds, and complex build workflows.</p> </li> </ul>"},{"location":"011-bake/#what-is-docker-buildkit","title":"What is Docker <code>BuildKit</code>?","text":"<ul> <li> <p>\ud83d\udc4d <code>BuildKit</code> is a modern build subsystem for Docker that improves performance, storage management, and caching  </p> </li> <li> <p>\ud83d\udc4d <code>BuildKit</code> is the engine behind <code>Docker Bake</code>, enabling advanced features like multi-platform builds, caching, and build secrets</p> </li> <li> <p>\ud83d\udc4d <code>BuildKit</code> is the default build engine for Docker, replacing the traditional docker build mechanism.</p> </li> <li> <p>\ud83d\udc4d <code>BuildKit</code> allows for parallel builds, advanced caching, and better resource utilization.</p> </li> <li> <p>\ud83d\udc4d <code>BuildKit</code> supports advanced features like build secrets, SSH forwarding, and more.</p> </li> <li> <p>\ud83d\udc4d <code>BuildKit</code> is a key component of the new Docker Engine 20.10 release, which includes the <code>buildkit</code> subcommand and the <code>docker buildx</code> command.</p> </li> </ul>"},{"location":"011-bake/#key-features","title":"Key Features","text":"Feature Description Advanced BuildKit Features Leverage BuildKit for caching, multi-platform builds, and advanced outputs. Advanced caching Sophisticated caching strategies for faster builds Build matrix Define multiple build configurations and targets Build secrets Securely pass sensitive information during builds Cache configuration Fine-tune caching strategies for faster builds CI/CD integration Ideal for automated build pipelines and workflows Concurrent Builds Build multiple images in parallel with a single command. Custom build arguments Specify different build arguments for each target Custom build contexts Specify different directories for each target Custom Dockerfiles Use different Dockerfiles for each target Declarative Build Configuration Define build targets, groups, arguments, tags, and more in a single file. Declarative syntax Use HCL, JSON, or YAML to define build configurations Extensibility Supports custom build steps and plugins Flexible File Formats Supports HCL (HashiCorp Configuration Language), JSON, and YAML (Compose extension). Group targets Organize multiple build targets into logical groups Inheritance Reuse common configurations across multiple targets Integration with Docker Compose You can use Compose files as Bake files for seamless migration. Matrix Builds Easily define build matrices for different platforms, versions, or configurations. Multi-platform builds Build for multiple architectures simultaneously (ARM, AMD64, etc.) Variable interpolation Use variables and functions for dynamic configurations"},{"location":"011-bake/#comparison-docker-bake-vs-docker-compose","title":"Comparison: Docker Bake vs Docker Compose","text":"Feature Docker Bake Docker Compose Purpose Build orchestration Service orchestration File Format HCL, JSON, YAML (Compose) YAML Parallel Builds Yes No Multi-platform Yes (via BuildKit) Limited Service Deploy No Yes Caching Advanced BuildKit caching Basic Inheritance Yes No CI/CD Ideal for CI/CD pipelines Limited Extensibility Supports custom build steps Limited Advanced Advanced build features Basic <p>[!WARNING]  <code>Docker Bake</code> requires Docker Engine v20.10.0 or higher. <code>Docker Bake</code> requires BuildKit for advanced build features.</p>"},{"location":"011-bake/#docker-bake-syntax","title":"Docker Bake syntax","text":"<p>[!IMPORTANT]  <code>docker-bake.hcl</code> is a declarative build configuration file format.  </p> <ul> <li>Here\u2019s a basic <code>docker-bake.hcl</code> file structure:</li> <li>It uses the HashiCorp Configuration Language (HCL) syntax for defining build configurations.</li> <li>This example defines two targets: <code>frontend</code> and <code>backend-api</code>, each with its own context, Dockerfile, tags, platforms, and build arguments.</li> </ul> <pre><code># Define variables\nvariable \"TAG\" {\n  default = \"latest\"\n}\n\n# Define a user variable for tagging images\n# This can be your Docker Hub username or any identifier\nvariable \"USER\" {\n  default = \"username\"\n}\n\n# Define a group of targets for default builds\ngroup \"default\" {\n  targets = [\"frontend\", \"backend-api\"]\n}\n\n# Frontend service\ntarget \"frontend\" {\n  # Directory containing the frontend code\n  context  = \"./frontend\"           \n\n  # Use a specific Dockerfile for production\n  dockerfile = \"Dockerfile.prod\" \n\n  # Tag the image with user and tag         \n  tags     = [\"${USER}/frontend:${TAG}\"]    \n\n  # Build for multiple architectures\n  platforms  = [\"linux/amd64\", \"linux/arm64\"]   \n\n  # Pass build-time variables to the Dockerfile \n  args = {\n    # Set Node.js environment to production\n    NODE_ENV = \"production\" \n\n    # Set API URL for the frontend\n    API_URL = \"https://api.codewizard.com\"\n  }\n}\n\n# Node.js backend service\ntarget \"backend-api\" {\n  context  = \"./backend\" \n  dockerfile = \"Dockerfile\"\n  tags     = [\"${USER}/backend:${TAG}\"]\n  platforms  = [\"linux/amd64\", \"linux/arm64\"]\n   args = {\n    NODE_ENV = \"production\"\n  }\n}\n</code></pre> <ul> <li>Here is another example of a <code>Docker Bake</code> configuration file: in JSON</li> </ul> <pre><code>{\n  \"variable\": {\n    \"TAG\": {\n      \"default\": \"latest\"\n    },\n    \"USER\": {\n      \"default\": \"username\"\n    }\n  },\n  \"group\": {\n    \"default\": {\n      \"targets\": [\"frontend\", \"backend-api\"]\n    }\n  },\n  \"target\": {\n    \"frontend\": {\n      \"context\": \"./frontend\",\n      \"dockerfile\": \"Dockerfile.prod\",\n      \"tags\": [\"${USER}/frontend:${TAG}\"],\n      \"platforms\": [\"linux/amd64\", \"linux/arm64\"],\n      \"args\": {\n        \"NODE_ENV\": \"production\",\n        \"API_URL\": \"https://api.codewizard.com\"\n      }\n    },\n    \"backend-api\": {\n      \"context\": \"./backend\",\n      \"dockerfile\": \"Dockerfile\",\n      \"tags\": [\"${USER}/backend:${TAG}\"],\n      \"platforms\": [\"linux/amd64\", \"linux/arm64\"],\n      \"args\": {\n        \"NODE_ENV\": \"production\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"011-bake/#common-commands","title":"Common Commands","text":"Feature Description Command Build Default Group Build all targets in the default group <code>docker buildx bake</code> Build Specific Target Build a specific target by name <code>docker buildx bake &lt;target&gt;</code> Build with Custom Variables Override variables for a specific build <code>docker buildx bake --set &lt;target&gt;.&lt;var&gt;=&lt;value&gt;</code> Build and Push Build images and push them to a registry <code>docker buildx bake --push</code> Build for Specific Platform Build images for a specific platform architecture <code>docker buildx bake --platform &lt;platform&gt;</code> View Build Configuration Print the effective build configuration <code>docker buildx bake --print</code> Build with Custom File Use a custom bake file instead of the default <code>docker buildx bake -f &lt;file&gt;</code>"},{"location":"011-bake/#advanced-features","title":"Advanced Features","text":""},{"location":"011-bake/#multi-stage-builds-with-matrix","title":"Multi-Stage Builds with Matrix","text":"<ul> <li>What is a Build Matrix?</li> <li>A build matrix allows you to create multiple image variations from a single configuration. </li> <li>This is useful when you need to build multiple versions of your application or service.</li> <li>For example, you might need to build different versions of your application for different environments (e.g., development, staging, production).</li> <li>By using a build matrix, you can specify multiple combinations of values for each configuration option.</li> <li> <p>Instead of writing separate targets for each combination, Docker Bake automatically generates all possible combinations.</p> </li> <li> <p>Example: Building multiple Node.js versions for different environments</p> </li> </ul> <pre><code>target \"app\" {\n  matrix = {\n    version = [\"18\", \"20\"]\n    env = [\"dev\", \"prod\"]\n  }\n\n  name = \"app-node${version}-${env}\"\n  context = \".\"\n  dockerfile = \"Dockerfile\"\n  tags = [\"myapp:node${version}-${env}\"]\n\n  args = {\n    NODE_VERSION = \"${version}\"\n    NODE_ENV     = \"${env}\"\n  }\n}\n</code></pre> <ul> <li>Quiz: What will be the output of the above example?</li> </ul> Answer <ul> <li>app-node18-dev</li> <li>app-node18-prod</li> <li>app-node20-dev</li> <li>app-node20-prod</li> </ul>    - Each build will use the specified Node.js version and environment.   - The `name` field dynamically constructs the image name based on the matrix values.   - The `args` field passes the Node.js version and environment as build arguments to the Dockerfile.   - The `tags` field tags the built images with the corresponding Node.js version and environment.   - The `context` and `dockerfile` fields specify the build context and Dockerfile to use for all builds.   - The `matrix` field defines the combinations of `version` and `env` to build."},{"location":"011-bake/#build-secrets","title":"Build Secrets","text":"<ul> <li><code>Build secrets</code> allow you to securely pass sensitive information (like API keys, passwords, or certificates) to your Docker build process without including them in the final image or build history.</li> <li>This is particularly useful for keeping sensitive data out of your Docker images and ensuring that it is only available during the build process. </li> <li><code>Build secrets</code> can be stored in a secure location, such as a secure vault or a secret management service, and then referenced during the build process.</li> <li><code>Build secrets</code> are mounted into the build environment at runtime, allowing you to use them without exposing them in the final image.</li> <li><code>Build secrets</code> are not stored in the final image layers, ensuring that sensitive information is not leaked.</li> <li><code>Build secrets</code> are only available during the build process and are not accessible to the final image or container.</li> <li><code>Build secrets</code> are defined in the <code>docker-bake.hcl</code> file using the <code>secret</code> field.</li> <li>You can use the <code>--secret</code> flag to pass secrets to the build process.</li> <li> <p>Secrets can also be defined in the Dockerfile using the <code>RUN --mount=type=secret</code> syntax.</p> </li> <li> <p>Example: Using a secret file during build</p> </li> </ul> <pre><code>target \"secure-app\" {\n  context = \".\"\n  dockerfile = \"Dockerfile\"\n  secret = [\n    \"id=mysecret,src=./secret.txt\"\n  ]\n  tags = [\"myapp:secure\"]\n}\n</code></pre> <ul> <li><code>Dockerfile</code>:</li> </ul> <pre><code>FROM node:18\n\n# Use the secret during build (it wont be in the final image)\n# as mentioned and explained above\n\nRUN --mount=type=secret,id=mysecret \\\n    API_KEY=$(cat /run/secrets/mysecret) &amp;&amp; \\\n    npm install --registry=https://registry.example.com\n</code></pre>"},{"location":"011-bake/#cache-configuration-build-caching","title":"Cache Configuration / Build Caching","text":"<ul> <li><code>Docker Bake</code> supports advanced caching strategies to speed up builds and reduce resource usage.</li> <li>Caching allows you to reuse previously built layers, which can significantly speed up the build process</li> <li><code>Docker Bake</code> can use different cache sources, such as local files, remote registries, or GitHub Actions cache.</li> <li>Caching can be configured using the <code>cache-from</code> and <code>cache-to</code> fields in the <code>docker-bake.hcl</code> file.</li> <li>Caching can also be configured using the <code>--cache-from</code> and <code>--cache-to</code> flags when running the <code>docker buildx bake</code> command.</li> <li>Caching can be used to speed up builds by reusing previously built layers, which can significantly reduce build times.</li> <li>Caching can also be used to reduce resource usage by avoiding unnecessary rebuilds of unchanged layers.</li> <li>Caching can be used to share build layers between different builds, which can further speed up the build process.</li> <li>Caching can be used to optimize the build process by reusing previously built layers, which can significantly reduce build times.</li> <li>Caching can reduce build times from minutes to seconds for unchanged code.</li> <li>Example: Using GitHub Actions cache</li> </ul> <pre><code>target \"cached-app\" {\n  context = \".\"\n  dockerfile = \"Dockerfile\"\n  cache-from = [\"type=gha\"]\n  cache-to = [\"type=gha,mode=max\"]\n  tags = [\"myapp:cached\"]\n}\n</code></pre> <p>Cache Types:</p> Type Description <code>type=gha</code> GitHub Actions cache (for CI/CD) <code>type=local</code> Local filesystem cache <code>type=registry</code> Docker registry cache"},{"location":"011-bake/#cache-configuration-build-caching-workflow","title":"Cache Configuration / Build Caching Workflow","text":"<p><code>mermaid flowchart TD     A[First build] --&gt;|Takes full time, saves cache| B[Second build]     B --&gt;|Reuses cached layers, builds only changed parts| C[Result]     C --&gt;|Significantly faster build times| D[End]</code></p>"},{"location":"011-bake/#target-inheritance","title":"Target Inheritance","text":"<ul> <li><code>Docker Bake</code> allows you to create a base configuration and reuse it across multiple targets. </li> <li>This follows the DRY (Don\u2019t Repeat Yourself) principle - define common settings once and inherit them.</li> </ul> <p>Example: Sharing common settings across multiple builds</p> Setting Description <code>target \"base\"</code> This is a base target that defines common build settings <code>context = \".\"</code> Uses the current directory as the build context <code>dockerfile = \"Dockerfile\"</code> Uses the default Dockerfile <code>platforms = [\"linux/amd64\", \"linux/arm64\"]</code> Builds for both AMD64 and ARM64 architectures <code>tags = [\"myapp:latest\"]</code> Sets the default tag for the image <code>cache-from = [\"type=gha\"]</code> Uses GitHub Actions cache for the build <code>cache-to = [\"type=gha,mode=max\"]</code> Saves the cache to GitHub Actions cache with <pre><code># Base target with common settings\ntarget \"base\" {\n  context = \".\"\n  dockerfile = \"Dockerfile\"\n  platforms = [\"linux/amd64\", \"linux/arm64\"]\n  tags = [\"myapp:latest\"]\n  cache-from = [\"type=gha\"]\n  cache-to = [\"type=gha,mode=max\"]\n}\n\n# Example: Using inheritance to define common settings (1)\ntarget \"web\" {\n  inherits = [\"base\"]\n  tags = [\"myapp/web:latest\"]\n  target = \"web\"\n}\n\n# Example: Using inheritance to define common settings (2)\ntarget \"api\" {\n  inherits = [\"base\"]\n  tags = [\"myapp/api:latest\"]\n  target = \"api\"\n}\n</code></pre> <p>How it works:</p> <p><code>mermaid flowchart TD     A[Base target] --&gt;|Defines common settings | B[Child targets]     B --&gt;|Inherit from base and add their specific settings| C[Result]     C --&gt;|Both web and api targets automatically get the same platforms and build context| D[End]</code></p> <p>Benefits:</p> <ul> <li>Consistency: Sharing - ensures consistent build configurations</li> <li>Reusability: All targets use the same base configuration</li> <li>Maintainability: Supports multiple targets with the same settings platforms in one place, affects all children</li> <li>Cleaner code: No repetitive configuration</li> <li>DRY principle: Avoids duplication of common settings</li> <li>Flexibility: Each target can still have its own specific settings</li> <li>Scalability: Easily add new targets with shared settings</li> </ul>"},{"location":"100-Hands-On/","title":"Index","text":""},{"location":"100-Hands-On/#basic-docker-hands-on-lab","title":"Basic Docker Hands-On Lab","text":"<ul> <li>In this lab we will create a simple NodeJs server and run it inside a docker container. </li> <li>Next, we will create a second container which will print some text to the screen. </li> <li>We will also create a docker hub account and push our images to the cloud.</li> </ul>"},{"location":"100-Hands-On/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1. Verify Docker installation</li> <li>2. Building our NodeJs server</li> <li>3. Test our server code</li> <li>3.1. Test if the server is running</li> <li>3.2. Stop the server</li> <li>4. Creating Docker containers</li> <li>4.1. Create <code>Dockerfile</code></li> <li>5. Build the Docker image</li> <li>5.1. Verifying that the container was created</li> <li>5.2. Testing the image</li> <li>5.3 Test if the server is running and listening:</li> <li>6. Container with arguments</li> </ul>"},{"location":"100-Hands-On/#1-verify-docker-installation","title":"1. Verify Docker installation","text":"<ul> <li>Run the following command in the shell to verify that Docker is installed and running</li> </ul> <pre><code>docker run node\n</code></pre>"},{"location":"100-Hands-On/#2-building-our-nodejs-server","title":"2. Building our NodeJs server","text":"<ul> <li>In this section we will create a simple NodeJs server and later on we will run it inside a docker container.</li> <li>First, we will create a folder for our server code and then we will create the server code file.</li> </ul> <pre><code># Create the desired folder\nmkdir hello-docker\n# Switch to the created directory\ncd hello-docker\n</code></pre> <ul> <li>Create our server code file (copy the code into this file) <code>server.js</code></li> </ul> <pre><code>// import the HTTP module\nvar http = require('http');\n\n// Define a port we want to listen to\nconst PORT=8080;\n\n// We need a function which handles requests and send response\nfunction handleRequest(request, response){\n  response.end('It Works!! Path Hit: ' + request.url);\n}\n\n// Create a server\nvar server = http.createServer(handleRequest);\n\n// Start our server\nserver.listen(PORT, function(){\n  //Callback triggered when server is successfully listening. Hurray!\n  console.log(\"Server listening on: http://localhost:%s\", PORT);\n});\n</code></pre>"},{"location":"100-Hands-On/#3-test-our-server-code","title":"3. Test our server code","text":"<ul> <li>You can run the server code using NodeJs by executing the following command.</li> <li>This will run the server and listen to port 8080</li> </ul> <pre><code>node server.js\n</code></pre>"},{"location":"100-Hands-On/#31-test-if-the-server-is-running","title":"3.1. Test if the server is running","text":"<ul> <li>If you are using Cloud Shell, you can test it by clicking on the most left icon (web preview) and open port 8080 which is our server port</li> <li>If you are running it locally, you can test it by opening your browser </li> <li>Use the following URL in your browser <code>http://localhost:8080</code></li> <li>You should see the following message in your browser or terminal   <pre><code>It Works!! Path Hit: /\n</code></pre></li> </ul>"},{"location":"100-Hands-On/#32-stop-the-server","title":"3.2. Stop the server","text":"<ul> <li>Type CTRL+C twice to stop the server</li> </ul>"},{"location":"100-Hands-On/#4-creating-docker-containers","title":"4. Creating Docker containers","text":""},{"location":"100-Hands-On/#41-create-dockerfile","title":"4.1. Create <code>Dockerfile</code>","text":"<ul> <li>In the same folder create the create a file called <code>Dockerfile</code> and add the following content:   <pre><code># Base image for Node.js\nFROM node:latest\n\n# Set the working directory in the container\nWORKDIR /usr/src/app\n\n# Copy the server file into the container \n# (Don`t forget the dot at the end)\nCOPY server.js .\n\n# Expose port 8080\n# This is the port our server will listen to\nEXPOSE 8080\n\n# Start the Node.js server\nCMD [ \"node\", \"server.js\" ]\n</code></pre></li> <li>This Dockerfile does the following:</li> <li>Uses the latest Node.js image as the base image</li> <li>Sets the working directory inside the container to <code>/usr/src/app</code></li> <li>Copies the <code>server.js</code> file from the current directory into the container\u2019s working directory</li> <li>Exposes port 8080 so that it can be accessed from outside the container</li> <li>Specifies the command to run when the container starts, which is <code>node server.js</code></li> </ul> <p>[!NOTE]  Make sure that the <code>Dockerfile</code> is in the same directory as the <code>server.js</code> file.</p> <p>[!IMPORTANT]  The <code>COPY</code> command in the Dockerfile is used to copy files from the host machine into the container. The first argument is the source file (in this case, <code>server.js</code>), and the second argument is the destination path inside the container (<code>.</code> means the current working directory in the container).</p>"},{"location":"100-Hands-On/#5-build-the-docker-image","title":"5. Build the Docker image","text":"<ul> <li> <p>In this step we will build the Docker image using the <code>Dockerfile</code> we created in the previous step.</p> <p>[!IMPORTANT]  Make sure you are in the same directory where the <code>Dockerfile</code> and <code>server.js</code> files are located.</p> </li> <li> <p>Build the image using docker build with the following parameters   <pre><code>--t = Tag name which will be attached to the container\n.   = The Context to the Dockerfile (current folder in our case)\n\n# Sample command to build the image\ndocker build -t hello-node:v1 .\n</code></pre></p> </li> </ul>"},{"location":"100-Hands-On/#51-verifying-that-the-container-was-created","title":"5.1. Verifying that the container was created","text":"<ul> <li>Let\u2019s verify that the image was created successfully by listing all the images on our system</li> <li>Run the following command to list all Docker images:   <pre><code>docker images\n</code></pre></li> <li>You should see an output similar to this:   <pre><code>REPOSITORY          TAG       IMAGE ID       CREATED          SIZE\nhello-node          v1        123456789abc   10 seconds ago   200MB\nnode                latest    abcdef123456   2 days ago       150MB\n</code></pre></li> </ul>"},{"location":"100-Hands-On/#52-testing-the-image","title":"5.2. Testing the image","text":"<ul> <li>Now we can run the container using the image we just created</li> <li>Execute <code>docker run</code> command with the following flags:</li> </ul> Option Description <code>-d</code> Run container in background (daemon mode) <code>-p</code> Map internal port 8080 to external port 8080 <code>hello-node:v1</code> The name of the image we just created <pre><code># Run the container in the background\ndocker run -d -p 8080:8080 hello-node:v1\n</code></pre>"},{"location":"100-Hands-On/#53-test-if-the-server-is-running-and-listening","title":"5.3 Test if the server is running and listening:","text":"<ul> <li>If you are using Cloud Shell, you can test it by clicking on the most left icon (web preview) and open port <code>8080</code> which is our server port</li> <li>If you are running it locally, you can test it by opening your browser </li> <li>Use the following URL in your browser <code>http://localhost:8080</code></li> <li>You should see the following message in your browser or terminal   <pre><code>It Works!! Path Hit: /\n</code></pre></li> </ul>"},{"location":"100-Hands-On/#6-container-with-arguments","title":"6. Container with arguments","text":"<ul> <li>Let\u2019s test another container which will print content to screen</li> </ul> <p>[!WARNING] You might get the following error:</p> <p>docker: [DEPRECATION NOTICE] Docker Image Format v1 and Docker Image manifest version 2, schema 1 support is disabled by default and will be removed in an upcoming release.</p> <ul> <li>Run the following command to run a container with arguments   <pre><code>docker run docker/whalesay cowsay boo\n</code></pre></li> <li>You should see the following output in your terminal   <pre><code>________\n&lt; boo &gt;\n--------\n        \\  ^__^\n        \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n</code></pre></li> </ul>"}]}